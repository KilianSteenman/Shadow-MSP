{
    parserClass="nl.shadowlink.mission.plugin.gta3script.parser.Gta3ScriptParser"
    parserUtilClass="nl.shadowlink.mission.plugin.gta3script.parser.Gta3ScriptParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Gta3Script"
    psiImplClassSuffix="Impl"
    psiPackage="nl.shadowlink.mission.plugin.gta3script.psi"
    psiImplPackage="nl.shadowlink.mission.plugin.gta3script.psi.impl"

    elementTypeHolderClass="nl.shadowlink.mission.plugin.gta3script.psi.Gta3ScriptTypes"
    elementTypeClass="nl.shadowlink.mission.plugin.gta3script.psi.Gta3ScriptElementType"
    tokenTypeClass="nl.shadowlink.mission.plugin.gta3script.psi.Gta3ScriptTokenType"

    psiImplUtilClass="nl.shadowlink.mission.plugin.gta3script.psi.Gta3ScriptUtils"

  tokens=[
    NEW_LINE="regexp:\\n"
    WHITE_SPACE='regexp:\\s+'
    NUMBER='regexp:-?\d+(\.\d*)?'
    COMMENT='regexp://.*'
    COMMENTBLOCK='regexp:\/\*(\*(?!\/)|[^*])*\*\/'

    // Reserved words
    MISSION_START='MISSION_START'
    MISSION_END='MISSION_END'
    WHILE = 'WHILE'
    END_WHILE = 'ENDWHILE'
    IF = 'IF'
    END_IF = 'ENDIF'
    ELSE = 'ELSE'
    AND = 'AND'
    OR = 'OR'
    RETURN = 'RETURN'
    SET = 'SET'
    NOT = 'NOT'
    ON = 'ON'
    OFF = 'OFF'
    TRUE = 'TRUE'
    FALSE = 'FALSE'
    GOSUB = 'GOSUB'

    GOSUB_IDENTIFIER='regexp:[a-zA-Z0-9_.]+:'
    IDENTIFIER='regexp:\$?[a-zA-Z0-9_.@&]+'

    OP_PLUS_PLUS='++'
    OP_PLUS='+'
    OP_MINUS_MINUS='--'
    OP_MINUS='-'
    OP_TIMES='*'
    OP_DIVISION='/'
    OP_LESS_THAN='<'
    OP_LESS_THAN_OR_EQUAL='<='
    OP_GREATER_THAN='>'
    OP_GREATER_THAN_OR_EQUAL='>='
    EQUALS='='
  ]
}

root ::= expression*
expression ::= (line_break | variable_definition | variable_assignment | label_identifier | subroutine_call | method_call | mission_block | if_expression | while_expression | math_operation | label_return | cast_assignment | local_scope | MISSION_END)

mission_block ::= MISSION_START expression*

subroutine_call ::= GOSUB subroutine_reference line_break
subroutine_reference ::= IDENTIFIER

label_identifier ::= GOSUB_IDENTIFIER line_break
label_return ::= RETURN

local_scope ::= '{' local_scope_body '}'
local_scope_body ::= expression*

variable_assignment ::= variable '=' (IDENTIFIER | NUMBER | Boolean) line_break
math_operation ::= (increment_pre_operation | increment_post_operation | math_operation_assignment | math_operation_self_assignment)
math_operator ::= OP_PLUS | OP_MINUS | OP_TIMES | OP_DIVISION
math_operation_assignment ::= IDENTIFIER EQUALS (IDENTIFIER | NUMBER) math_operator (IDENTIFIER | NUMBER)
math_operation_self_assignment ::= IDENTIFIER math_operator EQUALS (IDENTIFIER | NUMBER)
increment_pre_operation ::= (OP_PLUS_PLUS | OP_MINUS_MINUS) IDENTIFIER line_break
increment_post_operation ::= IDENTIFIER (OP_PLUS_PLUS | OP_MINUS_MINUS) line_break
cast_assignment ::= IDENTIFIER EQUALS '#' IDENTIFIER line_break

method_call ::= method_name MethodParamList line_break
method_name ::= IDENTIFIER

variable_definition ::= Type variable (','? variable)* line_break
variable ::= IDENTIFIER
line_break ::= NEW_LINE

if_expression ::= IF condition_list condition_body (ELSE condition_body)? END_IF line_break
while_expression ::= WHILE condition_list condition_body END_WHILE line_break
and_condition ::= AND condition
or_condition ::= OR condition
condition_list ::= condition (and_condition | or_condition)*
condition_body ::= expression*
condition ::= NOT? (method_call | comparison)
comparison ::= Param ComparisonOperator Param line_break

Type ::= VAR_INT | VAR_FLOAT

MethodParamList ::= MethodParamDefinition?
MethodParamDefinition ::= Param MethodParamDefinition? | '(' Param* ')' MethodParamDefinition?
VariableReference ::= IDENTIFIER {
    methods=[getReference]
}

Param ::= NUMBER | VariableReference | SUBROUTINE | Boolean | GxtReference
GxtReference ::= '(' IDENTIFIER ')'
Boolean ::= TRUE | FALSE | ON | OFF
ComparisonOperator ::= OP_LESS_THAN | OP_GREATER_THAN | OP_GREATER_THAN_OR_EQUAL | OP_LESS_THAN_OR_EQUAL | EQUALS